## Q:1058
> ### *和++优先级
>    
	int arr[10] = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
    int * pt = arr;    
	printf("%d\n",*(pt+3));
    printf("%d\n",*pt++);
    printf("%d\n",*(pt++));
    printf("%d\n",(*pt)++);
    printf("%d\n",++(*pt));

> 结果7 1 3 5 7
> 
> <font color = 'red'>
> * 和 ++ 优先级一样，但是是右结合，<br>
> \*p++和\*（p++）含义相同<br>
> 至于打印结果，解释为++后置前置的影响，先使用再自增
> </font>


## Q:1044
> ### pow误差
> `int tmp = (int)(pow(10,index)+0.5)*(s[i]-'0');`

> pow计算int会有误差，比如pow(10,8)会变成9999999，
> 解决办法为加上0.5再转成int
> 
><font color = 'red'> `(int)(pow(10,index)+0.5)`</font>


## Q:1050
> ###百鸡问题
> `用不超过n元去买100只鸡，大鸡5元/只，小鸡3元/只,还有1/3元每只的一种小鸡，分别记为x只, y只, z只。`
>` 编程求解x, y, z所有可能解。`

> ### 避免float问题
>> 所有数据乘以3
> ### 循环条件，不是<100,
>>         for (i = 0; i <= n / 15; i++) //不是<100
        {
            for (j = 0; j <= (n - 15 * i) / 9; j++) 
			//不是小于100
            {
                k = 100 - i - j;


## Q:int 除法变成double
> * `printf("%.2lf\n", - c / (double)b);`
> * `printf("%.2lf\n", - b / (2.0 * a));`


## Q:scanf(),gets(),fgets()
<pre><code>
= 字符串输入的对与错 =

 == 背景 ==


已知有一个字符数组str和一个二维字符数组key。

char str[1010], key[10][20];

其中str包含1010个char（对于本题而言，不能只写1000）；而key包含10×20个char。

对于key而言，它是个[包含10个元素的数组]，其中每个元素是[包含20个char的数组]，也就是“字符串”的数组。


== 说明 ==

0. scanf的每个参数都应该是指针。对于基本类型的变量而言，加上&，表示取指针。例如有 int a = 0; 则 &a 是 a 的指针。

1. 输入字符串的时候，要给输入函数的是字符数组的地址（指针），也就是连续n个char字符的首地址。

2. str就是字符数组的地址，key[i]是第key中第 i 个字符数组的地址。所以不需要&符号。

3. str[0]是一个char，是str的首字符，所以它的指针 &str[0] 也就是字符数组的地址，也就等于 str 。

 
== 正确 ==

scanf("%s", str); //遇到空格、回车、制表符就输入结束；注意回车还会留在输入缓冲里，最后补上'\0';
gets(str); //遇到回车结束，回车会被吃掉，但不会填入str，最后补上'\0'。
fgets(str, 1010, stdin); //遇到回车结束，或者是输入达到1000个字符也结束。回车会被吃掉，也会被填入str；最后补'\0'。


由于 &str[0] 的值和 str 是相等的（都是数组的首地址），所以下面这三个也是正确的：
scanf(%s", &str[0]);
gets(&str[0]);
fges(&str[0], 1000, stdin);


对于字符数组的数组，下面这些输入方式也是正确的：
scanf("%s", key[i]);
scanf("%s", &key[i][0]);
同理，gets和fgets也可以用 key[i] 或 &key[i][0]。


== 错误 ==

scanf("%s", &str); //不是要str的地址。str本身就是地址。
scanf("%s", str[0]); //str[0]是一个字符；scanf要的是要连续n个char的首地址。
scanf("%s", str[1010]); //这个跟上面的没有本质区别，str[1010]也是个字符，而且还是数组之外的字符，访问越界，bong，崩溃。


scanf("%s", &key);
scanf("%s", &key[i]);
scanf("%s", key[i][0]);
scanf("%s", key[i][20]);


同理，如果在gets和fgets等其他输入函数中出现这些写法，也都是错误的。


== 扩展 ==


1. 对于三维字符数组char X[10][20][30]，应该怎样用scanf输入？

 
答案：


...
...
..
...
...


for (i = 0; i < 10; i++)
    for (j = 0; j < 20; j++)
        scanf("%s", X[i][j]);


2. scanf和gets的混合输入问题。详见1071题的hint。
</pre></code>

## Q:字符串
<pre><code>
测试的时候，你的程序可以正常输入数据吗？

把输入的 a b c m n 都用 printf 打出来看看，是不是遇到问题了？

== 思考 ==

对于下面这个代码，如果用户输入是 123回车 ，会有什么效果？为什么？


#include <stdio.h>

int main() {

    int a;

    char str[100];

    scanf("%d", &a);

    gets(str);

    printf("a = %d, str = [%s]\n", a, str);

    return 0;

}

== 分析 ==

若用户输入 123回车 ，则系统在输入缓冲区里头填入了4个字符 "123\n"。

scanf从输入缓冲区中读取了"123"三个数字字符后遇到"\n"，会将"\n"原封不动地留在缓冲区中，并将"123"转换成整型存进变量a。

接下来执行gets()，它读取到的第一个字符是 "\n"，也就是遇到了“行末”，于是gets()在str[0]填入了一个'\0'就返回了。

所以程序的输出是 "a = 123, str = []"

== 解决 ==

1. 最直观的解决方案是，在 scanf("%d", &a); 后面加上一句 getchar(); 这样便能将剩下的一个 "\n" 字符给吃掉，就不会影响 gets() 函数的输入了。但问题是，如果用户输入的是  123空格回车 ，那么getchar() 读取到的就是空格，而回车仍然留在缓冲区中。

2. 另一个解决方案是，使用 scanf("%d\n", &a); 来进行输入。scanf会读入123对a赋值，然后读取并丢弃所有空白字符，[直到]遇到一个非空白字符为止（该字符不会被读取，仍然留在缓冲区中）。

   注：原自ccfaq http://c-faq-chn.sourceforge.net/ccfaq/node206.html 

   13.15 当我用 "%d\n" 调用 scanf 从键盘读取数字 的时候, 好像要多输入一行函数才返回。 

   = 可能令人吃惊, \n 在 scanf 格式串中不表示"等待换行符", 而是读取并放弃所有的空白字符。 

3. 对于Windows下的程序，可以使用fflush(stdin)去掉多余的回车等字符，但是对于Linux则无效（本系统运行于Linux之上）。

</pre></code>